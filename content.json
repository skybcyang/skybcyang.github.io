{"posts":[{"title":"第一张像样的照片","text":"拍了一下蒲公英，一开始还不会触碰对焦，蹲在花坛边对焦了好久，难为了我和我的18-135镜头。 2020年6月27日更新：那时候既不会手动对焦，也不会点击屏幕选择对焦点，有点睿智。。。换成了bilibili图床，加载速度快了不少。暂时还是出于随便拍拍玩玩的阶段，所以现在就不弄自己的图床了。","link":"/2020/06/04/First-Photo/"},{"title":"Ubuntu18.04终端更换为深度终端","text":"之前从Deepin到Ubuntu18多多少少有点不适应，特别是终端，所以心血来潮把Ubuntu的终端换成深度终端。 深度终端安装加入官方源，安装就完事了 sudo add-apt-repository ppa:noobslab/deepin-sc sudo apt-get update sudo apt-get install deepin-terminal 改成默认终端首先 安装dconf-tools apt-get install dconf-tools 打开dconf 搜索exec 关闭默认配置，在Custom value输入deepin-terminal 然后就可以Ctrl+Alt+T了 最后祝使用深度终端愉快！","link":"/2018/12/29/Change-Terminal/"},{"title":"LeetCode解题记录","text":"https://github.com/skybcyang/LeetCode 用C++语言解LeetCode题目。 采用Chrome插件LeetHub对英文LeetCode网站上的答题同步到Github的策略。","link":"/2020/06/27/Github-Repo-Leetcode/"},{"title":"主题Icarus定制化","text":"博客迁移后，主题也从nexT切换成icarus，我的一些定制化配置。所有改动都上传到我的fork的仓库里了，地址： https://github.com/skybcyang/hexo-theme-icarus 语言设置为中文编辑hexo目录下的_config.xml文件 language: zh-CN 导航栏标题设置编辑themes/icarus/目录下的_config.xml文件 menu: Home: / Archives: /archives Categories: /categories Tags: /tags About: /about 改为 menu: 主页: / 分类: /categories Leetcode: /categories/leetcode Github: /categories/github 随笔: /categories/essay 游戏: /categories/game 摄影: /categories/images 归档: /archives 标签: /tags 关于: /about 三列改为两列把所有wedgit改到左边，改变布局比例首先在themes/icarus/_config.yml修改所有的wedget到left对齐但是文章区域比较窄，修改themes/icarus/layout/layout.ejs 把layout/common/widget.ejs中side_column_class()的case 2的返回值改成return ‘is-4-tablet is-4-desktop is-3-widescreen’;就好啦！ 添加评论现在想要添加gitment作为评论的体系， 添加分享themes/icarus/_config.yml share: # Share plugin name type: sharejs 添加目录确保themes/icarus/_config.yml中有 widgets: - # Widget name type: toc # Where should the widget be placed, left or right position: left 然后在文章头部添加标签 toc: true 文章置顶功能在themes/icarus/_config.yml配置 index_generator: path: '' per_page: 10 order_by: top: -1 date: -1 修改/⁨node_modules⁩/hexo-generator-index⁩/lib⁩/generator.js var paginationDir = config.pagination_dir || 'page'; // added code posts.data = posts.data.sort(function(a, b) { if(a.top &amp;&amp; b.top) { if(a.top == b.top) return b.date - a.date; else return b.top - a.top; } else if(a.top &amp;&amp; !b.top) { return -1; } else if(!a.top &amp;&amp; b.top) { return 1; } else return b.date - a.date; }); // end var path = config.index_generator.path || ''; 修改模板中的post.md，添加top属性并设置默认值为0 /scaffolds/post.md --- title: {{ title }} date: {{ date }} tags: top: 0 --- 最后，根据大家自己的喜好在前端添加标签咯~ /themes/icarus/layout/common/article.ejs &lt;% if (post.top&gt;0) { %&gt; &lt;i class=&quot;fas fa-arrow-alt-circle-up&quot; style=&quot;color:#3273dc&quot;&gt;&lt;/i&gt; &lt;span class=&quot;level-item&quot; style=&quot;color:#3273dc&quot;&gt;&amp;nbsp;置顶&lt;/span&gt; &lt;% } %&gt; 添加阅读计数增加看板娘在hexo目录下执行 npm install --save hexo-helper-live2d 后来觉得不好看就卸掉了 npm uninstall hexo-helper-live2d 修改社交链接Icarus的默认社交链接有Github,Facebook,Twiter,Dribbble,RSS需要定制化图标是文件 注释最近文章的图片展示我觉得最近文章的图片展示太花里胡哨了，想要去掉在themes/icarus/layout/widget/recetn_posts.ejs中注释掉 &lt;!-- &lt;% if (!has_config('article.thumbnail') || get_config('article.thumbnail') !== false) { %&gt; &lt;a href=&quot;&lt;%- url_for((post.link?post.link:post.path)) %&gt;&quot; class=&quot;media-left&quot;&gt; &lt;p class=&quot;image is-64x64&quot;&gt; &lt;img class=&quot;thumbnail&quot; src=&quot;&lt;%= get_thumbnail(post) %&gt;&quot; alt=&quot;&lt;%= post.title %&gt;&quot;&gt; &lt;/p&gt; &lt;/a&gt; &lt;% } %&gt; --&gt; 展示侧边栏定制化主题默认的是在所有页面都展示相同的侧边栏，我觉得有些信息冗余，比如说在阅读文章时就不需要展示友链信息。所以得对不同页面下的侧边栏展示做一个定制化。 添加自定义图标在个人介绍侧边栏中的社交链接图标如facebook、\btwitter等平时几乎不用，所以换成了平时常用的网易云、微博等链接，图标定义如下 weibo cloudmusic steam 这些都是有对应的图标的，都在对应体系中原先是添加了微博的图标，但是微博没事让我关注一些奇怪的博主，于是我决定卸载微博的app，在博客中也去掉微博的链接 后记后来不用了，改成了新主题Fluid，除了改改主题颜色背景图等，也不再关注博客功能了，思想改了吧，还是应该以输出内容为主。","link":"/2019/09/27/Icarus-Customization/"},{"title":"Linux学习--内存寻址","text":"我们现在大多数pc机器是冯诺伊曼结构，冯诺伊曼结构的鼻祖是以输入输出和状态转移函数为核心的图灵机，冯诺伊曼结构的重点在于，内存寻址某种意义上代表了计算机技术。 – 陈莉君。 那我们就开始这一章的学习把。 我觉得这一张最令人疑惑的点就在于计分段机制，分段机制这个东西几乎所有的大学老师都避而不谈，而对分页机制大讲特讲。我觉得原因有三： 因为这个东西真的不重要，现在操作系统例如linux绕过了端机制，主要用的是页机制。 要弄明白需要背景知识十分扎实，对于处理器的结构有一定了解 端机制的引入最好是追溯到8086处理器的出现，借助历史才能完全弄懂 但是我们这篇文章的目的就是为了让你弄懂端机制 从8080-&gt;8086-&gt;80286-&gt;80386的演进，我们将把分段机制、保护模式、分页机制说清楚。 插一则轶事，我曾在部门内部的学习会上尝试着把这个东西说清楚，但是效果非常地差，并不是每个人都对背后的知识感兴趣，想听懂这个起码是已经跑过中间的点的程度，但是大部分人都是属于躺在家里还没有出门的那种，所以我那次培训效果奇差，事后我做了一些反思，详情见我这一篇文章。","link":"/2019/11/04/Memory-Addressing/"},{"title":"Python-Challenge(上)","text":"在家无事，翻阅有道云笔记中前几年的资料发现了完成了一半的Python-Challenge游戏，本文是几年前写的内容。 今天来玩一款小游戏，python解谜闯关网站，链接是www.pythonchallenge.com本文含有大量剧透，攻略向，看到感兴趣想动手试试的时候请紧急刹车。自己动手，乐趣无穷。 0 根据提示要改变url，也就是url http://www.pythonchallenge.com/pc/def/0.html 的0，根据图片中的2^38，在python交互模式中输入2**38，得到274877906944L，其中L表示长整型。 在浏览器输入 http://www.pythonchallenge.com/pc/def/274877906944.html 让我们进入下一关。 1 给了这样一串英文： g fmnc wms bgblr rpylqjyrc gr zw fylb. rfyrq ufyr amknsrcpq ypc dmp. bmgle gr gl zw fylb gq glcddgagclr ylb rfyr’q ufw rfgq rcvr gq qm jmle. sqgle qrpgle.kyicrpylq() gq pcamkkclbcb. lmu ynnjw ml rfc spj. 提示是：K -&gt; M ; O -&gt; Q ; E -&gt; G 这一关应该是把那一串字符按照规则解谜，首先发现只做上面三条替换还是得不到通顺的句子，而上面三条规则都是替换了ASCII + 2的字母，所以每个字母都应该这样处理（y z要额外减去26）。 一开始用了很笨的方法，用ord() 方法将字母转化为ASCII码做+2（或-24）处理，然后再用chr()把ASCII码转化为字母。 解密之后得到这样一句话： i hope you didnt translate it by hand. thats what computers are for. doing it in by hand is inefficient and that’s why this text is so long. using string.maketrans() is recommended. now apply on the url. 按照提示和现有url：http://www.pythonchallenge.com/pc/def/map.html ，改进了代码，试了一下 map –&gt; ocr，新的url是：http://www.pythonchallenge.com/pc/def/ocr.html 2 打开html，在一个隐蔽的角落里藏了一大坨乱码字符，大概是下面这样 眼尖的室友发现其中夹杂着一些小写字母，不管，先保存到html1.txt，再筛选出来。 筛选a~z之间的字母，最后连成一个单词 equality 得到下一关的url ：http://www.pythonchallenge.com/pc/def/equality.html 3 题目意思是，找出前后分别只有三个大写字母的小写字母。 这里可以看到网页的标签是re，提示我们使用re 按照上一题的尿性，也是在html里发现一大堆乱码，也是先存在html2.txt下。 在程序前面import re，下面是源代码 运行结果是 linkedlist所以新的url是：http://www.pythonchallenge.com/pc/def/linkedlist.html跳转的时候发现网页提示linkedlist.php，所以把html改成php跳转第四关 4没有任何提示 好吧，研究了半分钟，决定乱点。发现点了上面那张图的下半张，会跳转一个网页，上有一句话and the next nothing is 44827 我们发现这时的url已经变成： http://www.pythonchallenge.com/pc/def/linkedlist.php?nothing=12345 所以改一下nothing=44827： http://www.pythonchallenge.com/pc/def/linkedlist.php?nothing=44827 继续修改： http://www.pythonchallenge.com/pc/def/linkedlist.php?nothing=45439 Your hands are getting tired and the next nothing is 94485 ……. 在手动输入了很多次之后，我觉得还是应该写一个程序（md，浪费了好久）返回头来看网站源码里有一句不超过四百次，我才知道我完全走入了误区。 在这里应该还是用正则匹配和爬虫抓取，（我去恶补完又回来了）学会了简单的使用，解决这一关应该是没问题了。 在import urllib2之后，代码如下，在nothing = ‘12345’, n = 400的时候运行。 这里没有使用正则匹配，怕他又玩什么幺蛾子，就这样，我运行了一会觉得不对劲，于是加了输出。 在nothing=16044的时候，网页的输出是Divide by two and keep going 于是ctrl + c 手动停止程序，把参数调整为nothing = ‘8022’ , n = 315 运行 这里太多懒得写了。。。 5 让我们读出图片中的山（应该是英文吧）查了一下源代码后发现 应该是读 peak hell sounds familiar what? 这里要考谐音，同时这个谐音应该还和python当中的某个包或者函数有关。（我就是在这里看了攻略，初学python，不识pickle） Google之后才知道有一个叫pickle的包，感兴趣的可以百度一下pickle是啥。 用迅雷贴上链接下载了 banner.p ，其实也可以url抓取。 Print 之后发现返回的是一个列表 列表里的每个元组由一个字符，一个数字组成。 这里猜一下，是不是一个由字符组成的画，上面有去往下一关的线索。 [[(‘ ‘, 95)], [(‘ ‘, 14), (‘#’, 5), (‘ ‘, 70), (‘#’, 5), (‘ ‘, 1)],猜一下这个意思是指：第一行有95个空格；第二行14个空格 + 5个’#’ + 70个空格 + 5个’#’ + 1个空格······添加如下代码 结果如下，哈哈哈，下一关走起！ 当时好像不止打到第五关，但是因为懒得记录就停了。 在这里偷偷记录下大学的时候吧，头一年有点迷茫，以前只要考高分，现在却没有了明确的目标，天天在图书馆泡着看了好多闲杂书，大二的时候呢终于在迷茫中失去了自我，开始日复一日地打游戏，因为当时上数学课觉得没有什么用，不懂为什么到了大学还是要学理论基础，看不到这些东西能在未来能给我带来什么，大二下的时候幡然醒悟，觉得自己不能再这样沉沦下去。于是重新捡起学习，一直到现在都还在还债的路上。 大二下的时候抓住一个机会，有个研究生助教找有兴趣的学生做一个项目，虽然没有帮上什么忙，但是让我接触到python了，之前学习c++并没有什么感觉，但是python的感觉不一样，学习的时候真的给我一种惊喜，之后的课设能用python写的就用python写，包括模式识别的课设（车牌识别）、中文信息处理（分词）、数据库和web技术等课设都是。现在看到当时学习的记录让我回忆起那段时光，也许就是那种喜欢才让我留下来继续学习计算机。","link":"/2019/10/16/Python-Challenge/"},{"title":"多线程下的单例模式","text":"单例模式作为最为常见的设计模式，一直被广泛使用。在重构一个项目做成多线程，识别到单例模式在多线程中具有一定的风险。 单例模式在某些时候我们需要确保系统中有且仅有一个实例，这时候就要用到单例模式，单例模式的要点有三个；一是某个类只能有一个实例；二是它必须自行创建这个实例；三是它必须自行向整个系统提供这个实例。 在多线程中，单例模式有如下风险 这个单例模式的类的所有普通成员也成为临界资源，需要保护 如果单例模式使用懒汉方式构建，可能会有生成多个实例的风险 下面就来介绍一下懒汉方式和饿汉方式 懒汉方式和饿汉方式懒汉模式和饿汉模式不同点在于，饿汉模式在第一次调用单例类的时候，类已经构造好了，而饿汉模式第一次被访问的时候才去构造。下面用代码来展示 饿汉模式 123456789class Singleton { ... Singleton&amp; getInst() { return *pInst; } ... Singleton* pInst;}Singleton* Singleton::pInst = new Singleton(); 懒汉模式 123456789101112class Singleton { ... Singleton&amp; getInst() { if(pInst == NULL) { pInst = new Singleton(); } return *pInst; } ... Singleton* pInst;}Singleton* Singleton::pInst = NULL; 双重锁DCLP双重锁DCLP，也就是double-checked-locking pattern,可以使用双重锁改善懒汉模式来确保只生成一个对象。每次getInst的时候 先判空 再上锁 再判空 代码如下 123456789101112131415class Singleton { ... Singleton&amp; getInst() { if(pInst == NULL) { Lock lock; if(pInst == NULL) { pInst = new Singleton(); } } return *pInst; } ... Singleton* pInst;}Singleton* Singleton::pInst = NULL; 但是DCLP只能保证生成一个对象，还是有风险的。 因为C++的new分为如下步骤， 分配内存 调用构造函数 把地址复制给指针 但是步骤2或者步骤3有可能被编译器优化调换了顺序，先执行步骤3再执行步骤2。 基于以上，我们来探讨一下DCLP的风险，比如说： 第一次访问这个对象的时候，线程A判空后加了锁，然后走到了pInst = new Singleton();，执行了步骤3还没有执行步骤2，现在指针pInst已经被赋值，但是那块地址还没有被构造函数初始化。 这时候线程B来访问对象，在第一次判空的时候直接return了指针，然后拿着还没有调用构造函数的类执行下面的操作。 所以可以得知DCLP还是有一定风险的，还不如采用饿汉模式，一方面是规避了单例模式在多线程的风险，另一方面在取单例的时候少一次判空操作。 后续理想是丰满的，现实是很骨感的。现在用的平台强制对内存进行管理，通过重载基类的operator new，系统初始化之后才能使用平台分配内存的api，不能使用饿汉模式在系统完成初始化之前就构造好单例类。无奈，最终采取了DCLP来保护单例模式，并且在线程串行初始化的时候构造单例类。 另外C++有volatile关键字，能够确保语句顺序不被编译器优化，是否加了volatile能够让DCLP奏效呢，下篇文章探讨。 参考文章：C++和双重检查锁定模式(DCLP)的风险","link":"/2019/01/23/Singleton-in-Multithread/"},{"title":"持续集成和Jenkins杂谈","text":"关于持续集成/持续部署/持续交付的认识和看法，以及我设计的一个CI/CD流程。 持续集成、部署和交付在写Jenkins的时候觉得还是把CI、CD和CD说一下吧。 持续集成(Continuous Integration) 持续部署(Continuous Deployment) 持续交付(Continuous Delivery) 开发工作流程一般是 ①code -&gt; ②build -&gt; ③integrate -&gt; ④test -&gt; ⑤delivery -&gt; ⑥deploy [持续集成]对应①到④，我对持续集成的理解是利用CI工具对提交的代码进行及时的集成、测试(测试真的很重要)，频繁的集成可以帮助开发者在代码开发阶段提前发现问题，发现问题的时间越早付出的代价就越小。 [持续交付]对应①到⑤，持续集成是持续交付的子集，在持续交付阶段需要将代码部署到类生产环境中，比如在持续交付过程中连接数据库做更多更丰富的测试,缩短迭代周期。 [持续部署]对应①到⑥，持续部署则是持续交付后面接着部署到生产环境，但是想要做到持续部署的全自动化还是很难的，因为要经历很多不同的环境，这些环境的搭建配置和管理都很复杂。 也有把这三个统称为持续集成的说法，只是最后部署与否的区别，喊CI又不准确，CI/CD比较合适吧，哈哈哈。 常用的集成工具 Travis-ci，是一个在线托管的CI服务，Github的好基友，每次commit都会触发Travis重构，开源项目免费，私人项目就有点贵了。使用Travis构建项目的时候还可以生成覆盖率报告等，最后你的repo上会有很多看起来很高大上的徽章。 Jenkins，Jenkins是一个用Java编写的集成工具,需要自己本地安装，像我这种普通玩家集成小项目用Jenkins就很舒服，不过很吃内存，我的云服务器升级到2G内存才能玩得动，现在还不敢用Jenkins去集成比较大的项目。 对于CI/CD的理解首先，一定要写好测试! * 3 其次，CI/CD是提高代码开发效率的手段，而不是目的，在实际使用中，选择自己喜欢的、用得顺手的、适合项目的工具并且根据需求做到④⑤⑥中的任一步，一般来说做到⑤就可以了。 最后，在玩CI/CD的时候也看看Docker，Docker可以提供的是干净的测试环境也方便之后的部署。 Jenkins Jenkins是一个用Java编写的开源的持续集成工具 官网奉上https://jenkins.io/,Jenkins使用范围很广，文档和教程很全，拥有众多插件，企业级使用一般是基于Jenkins1.0进行二次开发来适应相应的构建流程（有空研究一下二次开发）。 在2018年上半年因为实习的缘故与Jenkins结缘，从此开始折腾，Jenkins的文档又臭又长，推荐看一遍Jenkins的文档目录，然后在自己的机器上或者是云服务器上自己安装一个Jenkins慢慢折腾，遇到问题再查文档。 安装配置Linux下添加apt源的方式，或是下载war包部署到Tomcat中。 安装运行后，默认运行端口是8080，访问serverurl:8080,会有一个unlock阶段，新建用户需要管理员权限，管理员密码在cat /var/lib/jenkins/secrets/initialAdminPassword中，不熟悉插件的话就按照推荐的安装一遍，使用教程不赘述，下面说一下Jenkins可以被用来做什么。 使用流程使用Jenkins集成测试项目时需要在Github中设置Webhook，每次Commit会发一个带有项目更新信息的Post给Jenkins服务器，要求Jenkins服务器的必须在公网下。Jenkins服务器接到了Webhook后拉去相应分支代码，在本地测试，docker构建镜像然后运行，可以很方便地看到每次提交后代码的构建状态和构建历史。 在使用的时候我比较喜欢BlueOcean——Jenkins的一个UI插件，美观顺手无脑，主要用来构建Pipeline项目，Pipeline的构建是根据Jenkinsfile走的，类似于Dockerfile，如果原先项目代码中没有Jenkinsfile，则会通过可视化操作引导创建一个使用流程，最后自动生成一个Jenkinsfile，也可以手动编写。Jenkinsfile使用groovy语法，指定agent、创建stages、执行steps等，下面是一个简单案例 1234567891011pipeline{ agent : any stages{ stage('start'){ sh 'echo hello,' } stage('end'){ sh 'echo world' } }} Jenkins通过自定义的流程可以完成很多事，官方文档中包括Build a Java app with Maven、Build a Node.js and React app with npm、Build a Python app with PyInstaller，这些都是一套完整的流程，一些可以插入的额外功能比如说设置环境变量、邮件提示、记录测试结果等。 使用的代码仓库github也好，自建的gitlab也行，设置好webhook就行。 使用阿里云的镜像仓库和Docker Swarm搭建服务（适用于中小型企业）的流程基本上如上图所示。Jenkins根据分支选择条件将打包的镜像推送到对应的镜像仓库，设置推送镜像自动触发构建，Docker Swarm就拉取镜像构建了。ps.阿里云的镜像仓库和Docker Swarm之间可以走内网，省一些流量费用。 关于这个模型的反思，根据关于两种CI/CD策略以及git分支模型的思考 – Bu・log，模型应该适当拉长流程，分隔出一个测试环境，理论来说，为了项目镜像的完全正确性，需要每次初始化一个新的环境进行测试，会耗费大量时间延长构建过程的周期，这里的取舍就见仁见智了。 注意点 修改Jenkins默认端口 123vi /etc/sysconfig/jenkins // 修改JENKINS_PORT为8081 JENKINS_PORT=&quot;8081&quot; Jenkins分为master节点和slave节点，master分配任务给slave，在构建任务并发的时候缓解压力。 可以使用参数化构建，根据变量回滚前几次的构建情况（没试验过）。参考使用jenkins进行项目的自动构建部署&amp;&amp;回滚 - 简书 参考文章谈谈持续集成，持续交付，持续部署之间的区别 持续集成系统的演进之路 关于两种CI/CD策略以及git分支模型的思考 – Bu・log Who is using Jenkins? - Jenkins - Jenkins Wiki 使用jenkins进行项目的自动构建部署&amp;&amp;回滚 - 简书 拓展阅读前端自动化测试探索 Log[2018-5-5]最近在忙毕设，我先把坑占好，原先Jenkins的东西就很多很杂，不然等做完毕业设计啥都不想干了全忘了那岂不是亏大发了。虽然我不是一个经验丰富的开发者，接触过的持续集成工具目前只有Jenkins，但是我希望我的想法能给你带来一些帮助。之后我也会去使用Travis-ci，对比一下,补充本文内容。[2018-5-9]添加了一些内容，但是还没有补全，未完待续。。。但是写着写着就像是使用教程了，之后应该还会修改，写博客的目的是为了传达idea，而不是简单的教程，警！限于认识的局限性，我对workflow的认识还很浅，暂时就没有写上去了，希望在后续的学习中能够弄明白，更新待续。。[2018-8-15]摸鱼了快两个月，好多东西都忘得差不多了，趁现在赶紧修改文章。在写博客的时候，想到什么写什么，很多地方不是使用过且深有体会的人是没办法跟上的，就先写成这样，之后多练练文笔，好好组织一下文章也许会好些。","link":"/2018/11/28/Use-Jenkins/"}],"tags":[{"name":"deepin","slug":"deepin","link":"/tags/deepin/"},{"name":"linux","slug":"linux","link":"/tags/linux/"},{"name":"hexo","slug":"hexo","link":"/tags/hexo/"},{"name":"icarus","slug":"icarus","link":"/tags/icarus/"},{"name":"设计模式","slug":"设计模式","link":"/tags/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/"},{"name":"单例模式","slug":"单例模式","link":"/tags/%E5%8D%95%E4%BE%8B%E6%A8%A1%E5%BC%8F/"},{"name":"Jenkins","slug":"Jenkins","link":"/tags/Jenkins/"},{"name":"CI&#x2F;CD","slug":"CI-CD","link":"/tags/CI-CD/"}],"categories":[{"name":"photo","slug":"photo","link":"/categories/photo/"},{"name":"github","slug":"github","link":"/categories/github/"}],"pages":[{"title":"about","text":"","link":"/about/index.html"}]}